{
  "version": 3,
  "sources": ["../../@thi.ng/checks/has-wasm.js", "../../@thi.ng/errors/deferror.js", "../../@thi.ng/errors/unsupported.js", "../../@thi.ng/transducers/compr.js", "../../@thi.ng/api/api.js", "../../@thi.ng/checks/implements-function.js", "../../@thi.ng/transducers/ensure.js", "../../@thi.ng/errors/illegal-arity.js", "../../@thi.ng/transducers/reduced.js", "../../@thi.ng/transducers/iterator.js", "../../@thi.ng/transducers-binary/base64.js", "../../@thi.ng/leb128/binary.js", "../../@thi.ng/leb128/index.js"],
  "sourcesContent": ["export const hasWASM = () => (typeof window !== \"undefined\" &&\n    typeof window[\"WebAssembly\"] !== \"undefined\") ||\n    (typeof global !== \"undefined\" &&\n        typeof global[\"WebAssembly\"] !== \"undefined\");\n", "export const defError = (prefix, suffix = (msg) => (msg !== undefined ? \": \" + msg : \"\")) => class extends Error {\n    constructor(msg) {\n        super(prefix(msg) + suffix(msg));\n    }\n};\n", "import { defError } from \"./deferror.js\";\nexport const UnsupportedOperationError = defError(() => \"unsupported operation\");\nexport const unsupported = (msg) => {\n    throw new UnsupportedOperationError(msg);\n};\n", "/**\n * Reducer composition helper, internally used by various transducers\n * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a\n * reducing function `fn`. Returns a new reducer tuple.\n *\n * @remarks\n * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.\n * `fn` accepts values of type `C` and produces interim results of type\n * `B`, which are then (possibly) passed to the \"inner\" `rfn[2]`\n * function. Therefore the resulting reducer takes inputs of `C` and an\n * accumulator of type `A`.\n *\n * It is assumed that `fn` internally calls `rfn[2]` to pass its own\n * results for further processing by the nested reducer `rfn`.\n *\n * @example\n * ```ts\n * compR(rfn, fn)\n * // [rfn[0], rfn[1], fn]\n * ```\n *\n * @param rfn -\n * @param fn -\n */\nexport const compR = (rfn, fn) => [rfn[0], rfn[1], fn];\n", "export const DEFAULT_EPS = 1e-6;\n/**\n * Internal use only. **Do NOT use in user land code!**\n *\n * @internal\n */\nexport const SEMAPHORE = Symbol();\n/**\n * No-effect placeholder function.\n */\nexport const NO_OP = () => { };\n/**\n * Catch-all event ID\n */\nexport const EVENT_ALL = \"*\";\nexport const EVENT_ENABLE = \"enable\";\nexport const EVENT_DISABLE = \"disable\";\n", "export const implementsFunction = (x, fn) => x != null && typeof x[fn] === \"function\";\n", "import { implementsFunction } from \"@thi.ng/checks/implements-function\";\nexport const ensureTransducer = (x) => implementsFunction(x, \"xform\") ? x.xform() : x;\n", "import { defError } from \"./deferror.js\";\nexport const IllegalArityError = defError(() => \"illegal arity\");\nexport const illegalArity = (n) => {\n    throw new IllegalArityError(n);\n};\n", "export class Reduced {\n    constructor(val) {\n        this.value = val;\n    }\n    deref() {\n        return this.value;\n    }\n}\nexport const reduced = (x) => new Reduced(x);\nexport const isReduced = (x) => x instanceof Reduced;\nexport const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);\nexport const unreduced = (x) => (x instanceof Reduced ? x.deref() : x);\n", "import { NO_OP, SEMAPHORE } from \"@thi.ng/api/api\";\nimport { isIterable } from \"@thi.ng/checks/is-iterable\";\nimport { ensureTransducer } from \"./ensure.js\";\nimport { push } from \"./push.js\";\nimport { isReduced, unreduced } from \"./reduced.js\";\n/**\n * Takes a transducer and input iterable. Returns iterator of\n * transformed results.\n *\n * @param xform -\n * @param xs -\n */\nexport function* iterator(xform, xs) {\n    const rfn = ensureTransducer(xform)(push());\n    const complete = rfn[1];\n    const reduce = rfn[2];\n    for (let x of xs) {\n        const y = reduce([], x);\n        if (isReduced(y)) {\n            yield* unreduced(complete(y.deref()));\n            return;\n        }\n        if (y.length) {\n            yield* y;\n        }\n    }\n    yield* unreduced(complete([]));\n}\n/**\n * Optimized version of {@link iterator} for transducers which are\n * guaranteed to:\n *\n * 1) Only produce none or a single result per input\n * 2) Do not require a `completion` reduction step\n *\n * @param xform -\n * @param xs -\n */\nexport function* iterator1(xform, xs) {\n    const reduce = (ensureTransducer(xform)([NO_OP, NO_OP, (_, x) => x]))[2];\n    for (let x of xs) {\n        let y = reduce(SEMAPHORE, x);\n        if (isReduced(y)) {\n            y = unreduced(y.deref());\n            if (y !== SEMAPHORE) {\n                yield y;\n            }\n            return;\n        }\n        if (y !== SEMAPHORE) {\n            yield y;\n        }\n    }\n}\n/**\n * Helper function used by various transducers to wrap themselves as\n * transforming iterators. Delegates to {@link iterator1} by default.\n *\n * @param xform -\n * @param args -\n * @param impl -\n *\n * @internal\n */\nexport const __iter = (xform, args, impl = iterator1) => {\n    const n = args.length - 1;\n    return isIterable(args[n])\n        ? args.length > 1\n            ? impl(xform.apply(null, args.slice(0, n)), args[n])\n            : impl(xform(), args[0])\n        : undefined;\n};\n", "import { compR } from \"@thi.ng/transducers/compr\";\nimport { iterator, iterator1, __iter } from \"@thi.ng/transducers/iterator\";\nimport { isReduced, reduced } from \"@thi.ng/transducers/reduced\";\nconst B64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst B64_SAFE = B64_CHARS.substring(0, 62) + \"-_\";\nexport function base64Decode(src) {\n    return src\n        ? new Uint8Array([...iterator1(base64Decode(), src)])\n        : (rfn) => {\n            const r = rfn[2];\n            let bc = 0, bs = 0;\n            return compR(rfn, (acc, x) => {\n                switch (x) {\n                    case \"-\":\n                        x = \"+\";\n                        break;\n                    case \"_\":\n                        x = \"/\";\n                        break;\n                    case \"=\":\n                        return reduced(acc);\n                    default:\n                }\n                const y = B64_CHARS.indexOf(x);\n                bs = bc & 3 ? (bs << 6) + y : y;\n                if (bc++ & 3) {\n                    acc = r(acc, 255 & (bs >> ((-2 * bc) & 6)));\n                }\n                return acc;\n            });\n        };\n}\nexport function base64Encode(...args) {\n    const iter = __iter(base64Encode, args, iterator);\n    if (iter) {\n        return [...iter].join(\"\");\n    }\n    return ([init, complete, reduce]) => {\n        let state = 0;\n        let b;\n        const opts = { safe: false, buffer: 1024, ...args[0] };\n        const chars = opts.safe ? B64_SAFE : B64_CHARS;\n        const buf = [];\n        return [\n            init,\n            (acc) => {\n                switch (state) {\n                    case 1:\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], \"=\", \"=\");\n                        break;\n                    case 2:\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], chars[(b >> 6) & 0x3f], \"=\");\n                        break;\n                    default:\n                }\n                while (buf.length && !isReduced(acc)) {\n                    acc = reduce(acc, buf.shift());\n                }\n                return complete(acc);\n            },\n            (acc, x) => {\n                switch (state) {\n                    case 0:\n                        state = 1;\n                        b = x << 16;\n                        break;\n                    case 1:\n                        state = 2;\n                        b += x << 8;\n                        break;\n                    default:\n                        state = 0;\n                        b += x;\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], chars[(b >> 6) & 0x3f], chars[b & 0x3f]);\n                        if (buf.length >= opts.buffer) {\n                            for (let i = 0, n = buf.length; i < n && !isReduced(acc); i++) {\n                                acc = reduce(acc, buf[i]);\n                            }\n                            buf.length = 0;\n                        }\n                }\n                return acc;\n            },\n        ];\n    };\n}\n", "// thing:no-export\n/**\n * Generated @ 2022-12-02T12:00:53Z\n *\n * @internal\n */\nexport const BINARY = \"AGFzbQEAAAABCgJgAX4Bf2AAAX4DBQQAAQABBQMBABEGCQF/AEGAgMAACwdYBgZtZW1vcnkCAA9sZWIxMjhFbmNvZGVVNjQAAANidWYDAA9sZWIxMjhEZWNvZGVVNjQAAQ9sZWIxMjhFbmNvZGVJNjQAAg9sZWIxMjhEZWNvZGVJNjQAAwrBAwRbAQJ/AkAgAEKAAVoEQANAIAFBgIBAayAAp0H/AHEgAEL/AFZBB3RyOgAAIAFBAWohASAAQoABVCAAQgeIIQBFDQALDAELQYCAwAAgADwAAEEBIQELIAFB/wFxC1ECA38CfgNAAkAgAEEBaiECIABBgIBAaywAACIBQf8Aca0gA4YgBIQhBCABQQBODQAgA0IHfCEDIABBCUkgAiEADQELC0GAgMAAIAI6AAAgBAuRAQEDfwJAIABCQH1CgAFaBEBBASECA0AgAkEBcUUNAiABQYCAQGtBAEGAfyAApyICQcAAcSIDRSAAQoABVHEgA0EGdiAAQgeHIgBCf1FxciIDGyACQf8AcXI6AAAgA0UhAiABQQFqIQEMAAsAC0GAgMAAIABCOYinQcAAcSAAp0E/cXI6AABBASEBCyABQf8BcQt+AgN/A35BfyEAA0ACQCAAQQFqIQEgA0IHfCEFIABBgYDAAGotAAAiAEH/AHGtIAOGIASEIQQgAMAiAkEATg0AIAEhACAFIQMgAUEJSQ0BCwtBgIDAACABQQFqOgAAIARCfyAFhkIAIAJBwABxQQZ2G0IAIAFB/wFxQQlJG4QL\";\n", "import { hasWASM } from \"@thi.ng/checks/has-wasm\";\nimport { unsupported } from \"@thi.ng/errors/unsupported\";\nimport { base64Decode } from \"@thi.ng/transducers-binary/base64\";\nimport { BINARY } from \"./binary.js\";\nlet wasm;\nlet U8;\nif (hasWASM()) {\n    const inst = new WebAssembly.Instance(new WebAssembly.Module(base64Decode(BINARY)));\n    wasm = inst.exports;\n    // mapped view of the data buffer\n    U8 = new Uint8Array(wasm.memory.buffer, wasm.buf, 16);\n}\nconst ensureWASM = () => !wasm && unsupported(\"WASM module unavailable\");\nconst encode = (op, signed) => (x) => {\n    ensureWASM();\n    const value = signed\n        ? BigInt.asIntN(64, BigInt(x))\n        : BigInt.asUintN(64, BigInt(x));\n    return U8.slice(0, wasm[op](value));\n};\nconst decode = (op, signed) => (src, idx = 0) => {\n    ensureWASM();\n    U8.set(src.subarray(idx, Math.min(idx + 10, src.length)), 0);\n    const value = wasm[op](0, 0);\n    return [\n        signed ? BigInt.asIntN(64, value) : BigInt.asUintN(64, value),\n        U8[0],\n    ];\n};\n/**\n * Encodes signed integer `x` into LEB128 varint format and returns\n * encoded bytes.\n *\n * @param x -\n */\nexport const encodeSLEB128 = encode(\"leb128EncodeI64\", true);\n/**\n * Takes Uint8Array with LEB128 encoded signed varint and an optional\n * start index to decode from. Returns 2-tuple of decoded value and\n * number of bytes consumed. Consumes up to 10 bytes from `src`.\n *\n * @param src -\n * @param idx -\n */\nexport const decodeSLEB128 = decode(\"leb128DecodeI64\", true);\n/**\n * Encodes unsigned integer `x` into LEB128 varint format and returns\n * encoded bytes. Values < 0 will be encoded as zero.\n *\n * @param x -\n */\nexport const encodeULEB128 = encode(\"leb128EncodeU64\", false);\n/**\n * Takes Uint8Array with LEB128 encoded unsigned varint and an optional\n * start index to decode from. Returns 2-tuple of decoded value and\n * number of bytes consumed. Consumes up to 10 bytes from `src`.\n *\n * @param src -\n * @param idx -\n */\nexport const decodeULEB128 = decode(\"leb128DecodeU64\", false);\n"],
  "mappings": "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",
  "names": []
}
