import { Buffer } from 'buffer/';
import { AccountInfo, AccountTransaction, AccountTransactionSignature, ConsensusStatus, ContractAddress, ContractContext, CryptographicParameters, InstanceInfo, InvokeContractResult, NextAccountNonce, SignedCredentialDeploymentDetails, TransactionStatus, Versioned } from './types';
import { AccountAddress } from './types/accountAddress';
import Provider from './providers/provider';
import { ModuleReference } from './types/moduleReference';
import { CredentialRegistrationId } from './types/CredentialRegistrationId';
export declare class JsonRpcClient {
    provider: Provider;
    constructor(provider: Provider);
    getNextAccountNonce(accountAddress: AccountAddress): Promise<NextAccountNonce | undefined>;
    getTransactionStatus(transactionHash: string): Promise<TransactionStatus | undefined>;
    /**
     * @param serializedTransaction the transaction serialized as a base64-encoded string.
     */
    private sendRawTransaction;
    sendAccountTransaction(accountTransaction: AccountTransaction, signatures: AccountTransactionSignature): Promise<boolean>;
    sendCredentialDeployment(credentialDetails: SignedCredentialDeploymentDetails): Promise<boolean>;
    getConsensusStatus(): Promise<ConsensusStatus>;
    /**
     * Retrieve information about a given smart contract instance.
     * @param blockHash the block hash to get the smart contact instances at
     * @param address the address of the smart contract
     * @returns A JSON object with information about the contract instance
     */
    getInstanceInfo(address: ContractAddress, blockHash?: string): Promise<InstanceInfo | undefined>;
    /**
     * Retrieves the account info for the given account. If the provided block
     * hash is in a block prior to the finalization of the account, then the account
     * information will not be available.
     * A credential registration id can also be provided, instead of an address. In this case
     * the node will return the account info of the account, which the corresponding credential
     * is (or was) deployed to.
     * @param accountAddress base58 account address (or a credential registration id) to get the account info for
     * @param blockHash the block hash to get the account info at
     * @returns the account info for the provided account address, undefined is the account does not exist
     */
    getAccountInfo(accountAddress: string | AccountAddress | CredentialRegistrationId, blockHash?: string): Promise<AccountInfo | undefined>;
    /**
     * Retrieves the global cryptographic parameters on the blockchain at
     * the provided block.
     * @param blockHash the block to get the cryptographic parameters at
     * @returns the global cryptographic parameters at the given block, or undefined it the block does not exist.
     */
    getCryptographicParameters(blockHash?: string): Promise<Versioned<CryptographicParameters> | undefined>;
    /**
     * Retrieves the source of the given module at
     * the provided block.
     * @param moduleReference the module's reference, which is the hex encoded hash of the source.
     * @param blockHash the block to get the cryptographic parameters at
     * @returns the source of the module as raw bytes.
     */
    getModuleSource(moduleReference: ModuleReference, blockHash?: string): Promise<Buffer>;
    /**
     * Invokes a smart contract.
     * @param context the collection of details used to invoke the contract. Must include the address of the contract and the method invoked.
     * @param blockHash the block hash at which the contract should be invoked at. The contract is invoked in the state at the end of this block.
     * @returns If the node was able to invoke, then a object describing the outcome is returned.
     * The outcome is determined by the `tag` field, which is either `success` or `failure`.
     * The `usedEnergy` field will always be present, and is the amount of NRG was used during the execution.
     * If the tag is `success`, then an `events` field is present, and it contains the events that would have been generated.
     * If invoking a V1 contract and it produces a return value, it will be present in the `returnValue` field.
     * If the tag is `failure`, then a `reason` field is present, and it contains the reason the update would have been rejected.
     * If either the block does not exist, or then node fails to parse of any of the inputs, then undefined is returned.
     */
    invokeContract(contractContext: ContractContext, blockHash?: string): Promise<InvokeContractResult | undefined>;
}
