/// <reference types="node" />
import { Readable } from 'stream';
import { ParameterType, SchemaVersion } from './types';
import { Buffer } from 'buffer/';
/**
 * Function that reags an output of specified type from {@link Readable}.
 *
 * @typeParam T - output type
 */
export interface Deserial<T> {
    (source: Readable): T;
}
/**
 * schema (V0) for a module, which is a
 * map of contract names to contract schemas.
 */
export declare type ModuleV0 = Record<string, ContractV0>;
/**
 * schema (V1) for a module, which is a
 * map of contract names to contract schemas.
 */
export declare type ModuleV1 = Record<string, ContractV1>;
/**
 * schema (V2) for a module, which is a
 * map of contract names to contract schemas.
 */
export declare type ModuleV2 = Record<string, ContractV2>;
/**
 * Versioned schema for a module.
 * Note that the version is the schema version and not the module version.
 */
export declare type VersionedModule = {
    v: SchemaVersion.V0;
    value: ModuleV0;
} | {
    v: SchemaVersion.V1;
    value: ModuleV1;
} | {
    v: SchemaVersion.V2;
    value: ModuleV2;
};
/**
 * Reads the schema (V0) for a contract module from the given {@link Readable}.
 *
 * @param source input stream
 * @returns schema (V0) of a module (contract map)
 */
export declare function deserialModuleV0(source: Readable): ModuleV0;
/**
 *  Reads the schema (V1) for a contract module from the given{@link Readable}.
 *
 * @param source input stream
 * @returns schema (V1) of a module (contract map)
 */
export declare function deserialModuleV1(source: Readable): ModuleV1;
/**
 *  Reads the schema (V2) for a contract module from the given{@link Readable}.
 *
 * @param source input stream
 * @returns schema (V2) of a module (contract map)
 */
export declare function deserialModuleV2(source: Readable): ModuleV2;
/**
 *  Magic prefix for versioned schemas, used to distinguish between a versioned
 *  schema and the older format without versioning as part of the schema.
 *
 *  The constant is corresponding to two maxed-out bytes, interpreted as a 16-bit unsigned integer.
 */
export declare const VERSIONED_SCHEMA_PREFIX = 65535;
/**
 *  Reads a versioned schema for a contract module from the given{@link Readable}.
 *
 * @param source input stream
 * @returns schema (Versioned) of a module (contract map)
 */
export declare function deserialVersionedModule(source: Readable): VersionedModule;
/**
 *   schema (V0) for a contract.
 */
export declare type ContractV0 = {
    /** Optional schema for the contract state. */
    state: Type | null;
    /** Optional schema for init function parameters. */
    init: Type | null;
    /** Map of receive function names to schemas for their respective parameters. */
    receive: Record<string, Type>;
};
/**
 *  schema (V1) for a contract.
 */
export declare type ContractV1 = {
    /** Optional schema for init function. */
    init: ContractFunctionV1 | null;
    /** Map of receive function names to schemas for their respective parameters and return values. */
    receive: Record<string, ContractFunctionV1>;
};
/**
 *  schema (V2) for a contract.
 */
export declare type ContractV2 = {
    /** Optional schema for init function. */
    init: ContractFunctionV2 | null;
    /** Map of receive function names to schemas for their respective parameters and return values. */
    receive: Record<string, ContractFunctionV2>;
};
/**
 * Reads {@link ContractV0} from the given {@link Readable}.
 *
 * @param source input stream
 * @returns schema (V0) for a contract.
 */
export declare function deserialContractV0(source: Readable): ContractV0;
/**
 * Reads {@link ContractV1} from the given {@link Readable}.
 *
 * @param source input stream
 * @returns schema (V1) for a contract.
 */
export declare function deserialContractV1(source: Readable): ContractV1;
/**
 * Reads {@link ContractV2} from the given {@link Readable}.
 *
 * @param source input stream
 * @returns schema (V2) for a contract.
 */
export declare function deserialContractV2(source: Readable): ContractV2;
/**
 * Size length of a {@link Type}, represented as an unsigned integer.
 */
export declare enum SizeLength {
    /** Takes 1 byte and represents a possible size range of 0..255. */
    U8 = 0,
    /** Takes 2 bytes and represents a possible size range of 0..65535. */
    U16 = 1,
    /** Takes 4 bytes and represents a possible size range of 0..4294967295. */
    U32 = 2,
    /** Takes 8 bytes and represents a possible size range of 0..2^64-1. */
    U64 = 3
}
/**
 * Contract schema type.
 */
export declare type Type = {
    typeTag: ParameterType.Unit | ParameterType.Bool | ParameterType.U8 | ParameterType.U16 | ParameterType.U32 | ParameterType.U64 | ParameterType.U128 | ParameterType.I8 | ParameterType.I16 | ParameterType.I32 | ParameterType.I64 | ParameterType.I128 | ParameterType.Amount | ParameterType.AccountAddress | ParameterType.ContractAddress | ParameterType.Timestamp | ParameterType.Duration;
} | PairType | ListType | MapType | ArrayType | StructType | EnumType | StringType | ULeb128Type | ILeb128Type | ByteListType | ByteArrayType;
export declare type ContractFunctionV1 = {
    parameter?: Type;
    returnValue?: Type;
};
export declare type ContractFunctionV2 = {
    parameter?: Type;
    returnValue?: Type;
    error?: Type;
};
export declare type StringType = {
    typeTag: ParameterType.String | ParameterType.ContractName | ParameterType.ReceiveName;
    sizeLength: SizeLength;
};
/**
 * Array type.
 */
export declare type ArrayType = {
    typeTag: ParameterType.Array;
    size: number;
    of: Type;
};
/**
 * Struct type.
 */
export declare type StructType = {
    typeTag: ParameterType.Struct;
    fields: Fields;
};
/**
 * Enum type.
 */
export declare type EnumType = {
    typeTag: ParameterType.Enum;
    variants: [string, Fields][];
};
/**
 * Map type.
 */
export declare type MapType = {
    typeTag: ParameterType.Map;
    sizeLength: SizeLength;
    ofKeys: Type;
    ofValues: Type;
};
/**
 * List type.
 */
export declare type ListType = {
    typeTag: ParameterType.List | ParameterType.Set;
    sizeLength: SizeLength;
    of: Type;
};
/**
 * Pair type.
 */
export declare type PairType = {
    typeTag: ParameterType.Pair;
    ofLeft: Type;
    ofRight: Type;
};
/**
 *  LEB128 for unsigned integers type.
 */
export declare type ULeb128Type = {
    typeTag: ParameterType.ULeb128;
    constraint: number;
};
/**
 *  LEB128 for signed integers type.
 */
export declare type ILeb128Type = {
    typeTag: ParameterType.ILeb128;
    constraint: number;
};
/**
 *  List of bytes type.
 */
export declare type ByteListType = {
    typeTag: ParameterType.ByteList;
    sizeLength: SizeLength;
};
/**
 *  Array of bytes type.
 */
export declare type ByteArrayType = {
    typeTag: ParameterType.ByteArray;
    size: number;
};
/**
 * Reads {@link ContractFunction} from the given {@link Readable}.
 *
 * @param source input stream
 * @returns Function schema type
 */
export declare function deserialFunctionV1(source: Readable): ContractFunctionV1;
/**
 * Reads {@link ContractFunctionV2} from the given {@link Readable}.
 *
 * @param source input stream
 * @returns Function schema type
 */
export declare function deserialFunctionV2(source: Readable): ContractFunctionV2;
/**
 * Reads {@link Type} from the given {@link Readable}.
 *
 * @param source input stream
 * @returns contract schema type
 */
export declare function deserialType(source: Readable): Type;
/**
 * {@link Fields} tag.
 */
export declare enum FieldsTag {
    /**
     * Represents named fields such as in
     * `struct RGB { r: u8, g: u8, b: u8 }`.
     */
    Named = 0,
    /**
     * Represents unnamed (anonymous) struct fields such as in
     * `struct Point { u32, u32 }`.
     */
    Unnamed = 1,
    /**
     * Represents lack of fields in a struct or an enum, as is the case
     * with `Cat` in `enum Animal { Cat, Dog, Human }`.
     */
    None = 2
}
/**
 * Rust flavored struct/enum fields.
 */
export declare type Fields = NamedFields | UnnamedFields | {
    fieldsTag: FieldsTag.None;
};
/**
 * Named fields if the type is Struct/enum
 */
export declare type NamedFields = {
    fieldsTag: FieldsTag.Named;
    contents: [string, Type][];
};
/**
 * Unnamed fields if the type is Struct/enum
 */
export declare type UnnamedFields = {
    fieldsTag: FieldsTag.Unnamed;
    contents: Type[];
};
/**
 * Reads {@link Fields} from the given {@link Readable}.
 *
 * @param source input stream
 * @returns struct or enum variant fields
 */
export declare function deserialFields(source: Readable): Fields;
/**
 * Reads a string from the given {@link Readable}.
 *
 * @param source input stream
 * @returns string
 */
export declare function deserialString(source: Readable): string;
/**
 * Takes a {@link Deserial} function of the given type and returns another
 * {@link Deserial} function that can read an array of the same type.
 *
 * @typeParam T - {@link Deserial} output type
 * @param deserial function that takes {@link Readable} and returns `T`
 * @returns function that takes {@link Readable} and returns an array of `T`
 */
export declare function deserialArrayFn<T>(deserial: Deserial<T>): Deserial<T[]>;
/**
 * Takes two {@link Deserial} functions of two given types: one for keys
 * and the other one for values. Returns another {@link Deserial} function
 * that can read a map with keys and values of corresponding types.
 *
 * @typeParam K - {@link Deserial} output type for keys
 * @typeParam V - {@link Deserial} output type for values
 * @param deserialKey function that takes {@link Readable} and returns `K`
 * @param deserialValue function that takes {@link Readable} and returns `V`
 * @returns function that takes {@link Readable} and returns a map from `K` to `V`
 */
export declare function deserialMapFn<K extends string, V>(deserialKey: Deserial<K>, deserialValue: Deserial<V>): Deserial<Record<K, V>>;
/**
 * Option tag.
 *
 * Options are equivalent to nullable types. They can be either
 * {@link OptionTag.None}, which means that the value is `null`, or
 * {@link OptionTag.Some}, which means that a non-`null` value is present.
 */
export declare enum OptionTag {
    /** Means that there's no value. */
    None = 0,
    /** Means that there's a value. */
    Some = 1
}
/**
 * Takes a {@link Deserial} function of the given type and returns another
 * {@link Deserial} function that can read an option wrapped (nullable)
 * version of the same type.
 *
 * @typeParam T - {@link Deserial} output type
 * @param deserial function that takes {@link Readable} and returns `T`
 * @returns function that takes {@link Readable} and returns `T` or `null`
 */
export declare function deserialOptionFn<T>(deserial: Deserial<T>): Deserial<T | null>;
/**
 * Takes two {@link Deserial} functions of two given types: one for left
 * values and the other one for right values. Returns another {@link Deserial}
 * function that can read a tuple with left and right values of corresponding
 * types.
 *
 * @typeParam L - {@link Deserial} output type for left values
 * @typeParam R - {@link Deserial} output type for right values
 * @param deserialLeft function that takes {@link Readable} and returns `L`
 * @param deserialRight function that takes {@link Readable} and returns `R`
 * @returns function that takes {@link Readable} and returns a tuple of `L` and `R`
 */
export declare function deserialTupleFn<L, R>(deserialLeft: Deserial<L>, deserialRight: Deserial<R>): Deserial<[L, R]>;
/**
 * Reads an unsigned 8-bit integer from the given {@link Readable}.
 *
 * @param source input stream
 * @returns number from 0 to 255
 */
export declare function deserialUint8(source: Readable): number;
/**
 * @param buffer Schema buffer
 * @param moduleVersion the version of the module (only needed for older versions of the schema).
 * @returns deserialized module of wasm file
 */
export declare function deserialModuleFromBuffer(buffer: Buffer, schemaVersion?: SchemaVersion): VersionedModule;
