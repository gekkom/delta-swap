import { AccountAddress } from './types/accountAddress';
import { CredentialRegistrationId } from './types/CredentialRegistrationId';
import { CcdAmount } from './types/ccdAmount';
import { DataBlob } from './types/DataBlob';
import { TransactionExpiry } from './types/transactionExpiry';
import { Buffer } from 'buffer/';
import { ModuleReference } from './types/moduleReference';
export declare type HexString = string;
/**
 * Returns a union of all keys of type T with values matching type V.
 */
export declare type KeysMatching<T, V> = {
    [K in keyof T]-?: T[K] extends V ? K : never;
}[keyof T];
export interface Versioned<T> {
    v: number;
    value: T;
}
export declare enum AttributesKeys {
    firstName = 0,
    lastName = 1,
    sex = 2,
    dob = 3,
    countryOfResidence = 4,
    nationality = 5,
    idDocType = 6,
    idDocNo = 7,
    idDocIssuer = 8,
    idDocIssuedAt = 9,
    idDocExpiresAt = 10,
    nationalIdNo = 11,
    taxIdNo = 12
}
export declare type Attributes = {
    [P in keyof typeof AttributesKeys]: string;
};
export declare type AttributeKey = keyof Attributes;
export declare enum AttributeKeyString {
    firstName = "firstName",
    lastName = "lastName",
    sex = "sex",
    dob = "dob",
    countryOfResidence = "countryOfResidence",
    nationality = "nationality",
    idDocType = "idDocType",
    idDocNo = "idDocNo",
    idDocIssuer = "idDocIssuer",
    idDocIssuedAt = "idDocIssuedAt",
    idDocExpiresAt = "idDocExpiresAt",
    nationalIdNo = "nationalIdNo",
    taxIdNo = "taxIdNo"
}
export declare enum Sex {
    NotKnown = "0",
    Male = "1",
    Female = "2",
    NA = "9"
}
export declare enum IdDocType {
    NA = "0",
    Passport = "1",
    NationalIdCard = "2",
    DriversLicense = "3",
    ImmigrationCard = "4"
}
export declare enum TransactionStatusEnum {
    Received = "received",
    Finalized = "finalized",
    Committed = "committed"
}
export interface AddressAccount {
    type: 'AddressAccount';
    address: string;
}
export declare type AccountIdentifierInput = AccountAddress | CredentialRegistrationId | bigint;
export interface TransactionEvent {
    tag: 'ModuleDeployed' | 'ContractInitialized' | 'AccountCreated' | 'CredentialDeployed' | 'BakerAdded' | 'BakerRemoved' | 'BakerStakeIncreased' | 'BakerStakeDecreased' | 'BakerSetRestakeEarnings' | 'BakerKeysUpdated' | 'CredentialKeysUpdated' | 'NewEncryptedAmount' | 'EncryptedAmountsRemoved' | 'AmountAddedByDecryption' | 'EncryptedSelfAmountAdded' | 'UpdateEnqueued' | 'TransferredWithSchedule' | 'CredentialsUpdated' | 'DataRegistered' | 'BakerSetOpenStatus' | 'BakerSetMetadataURL' | 'BakerSetTransactionFeeCommission' | 'BakerSetBakingRewardCommission' | 'BakerSetFinalizationRewardCommission' | 'DelegationStakeIncreased' | 'DelegationStakeDecreased' | 'DelegationSetRestakeEarnings' | 'DelegationSetDelegationTarget' | 'DelegationAdded' | 'DelegationRemoved';
}
export interface ContractAddress {
    index: bigint;
    subindex: bigint;
}
export interface InterruptedEvent {
    tag: 'Interrupted';
    address: ContractAddress;
    events: string[];
}
export interface ResumedEvent {
    tag: 'Resumed';
    address: ContractAddress;
    success: boolean;
}
export interface UpdatedEvent {
    tag: 'Updated';
    address: ContractAddress;
    instigator: AddressAccount;
    amount: bigint;
    message: string;
    receiveName: string;
    events: [string];
}
export interface TransferredEvent {
    tag: 'Transferred';
    amount: bigint;
    to: AddressAccount;
    from: AddressAccount;
}
export interface TransferredWithScheduleEvent {
    tag: 'TransferredWithSchedule';
    to: AddressAccount;
    from: AddressAccount;
    amount: ReleaseSchedule[];
}
export interface MemoEvent {
    tag: 'TransferMemo';
    memo: string;
}
/**
 * An enum containing all the possible reject reasons that can be
 * received from a node as a response to a transaction submission.
 *
 * This should be kept in sync with the list of reject reasons
 * found here: https://github.com/Concordium/concordium-base/blob/main/haskell-src/Concordium/Types/Execution.hs
 */
export declare enum RejectReasonTag {
    ModuleNotWF = "ModuleNotWF",
    ModuleHashAlreadyExists = "ModuleHashAlreadyExists",
    InvalidAccountReference = "InvalidAccountReference",
    InvalidInitMethod = "InvalidInitMethod",
    InvalidReceiveMethod = "InvalidReceiveMethod",
    InvalidModuleReference = "InvalidModuleReference",
    InvalidContractAddress = "InvalidContractAddress",
    RuntimeFailure = "RuntimeFailure",
    AmountTooLarge = "AmountTooLarge",
    SerializationFailure = "SerializationFailure",
    OutOfEnergy = "OutOfEnergy",
    RejectedInit = "RejectedInit",
    RejectedReceive = "RejectedReceive",
    NonExistentRewardAccount = "NonExistentRewardAccount",
    InvalidProof = "InvalidProof",
    AlreadyABaker = "AlreadyABaker",
    NotABaker = "NotABaker",
    InsufficientBalanceForBakerStake = "InsufficientBalanceForBakerStake",
    StakeUnderMinimumThresholdForBaking = "StakeUnderMinimumThresholdForBaking",
    BakerInCooldown = "BakerInCooldown",
    DuplicateAggregationKey = "DuplicateAggregationKey",
    NonExistentCredentialID = "NonExistentCredentialID",
    KeyIndexAlreadyInUse = "KeyIndexAlreadyInUse",
    InvalidAccountThreshold = "InvalidAccountThreshold",
    InvalidCredentialKeySignThreshold = "InvalidCredentialKeySignThreshold",
    InvalidEncryptedAmountTransferProof = "InvalidEncryptedAmountTransferProof",
    InvalidTransferToPublicProof = "InvalidTransferToPublicProof",
    EncryptedAmountSelfTransfer = "EncryptedAmountSelfTransfer",
    InvalidIndexOnEncryptedTransfer = "InvalidIndexOnEncryptedTransfer",
    ZeroScheduledAmount = "ZeroScheduledAmount",
    NonIncreasingSchedule = "NonIncreasingSchedule",
    FirstScheduledReleaseExpired = "FirstScheduledReleaseExpired",
    ScheduledSelfTransfer = "ScheduledSelfTransfer",
    InvalidCredentials = "InvalidCredentials",
    DuplicateCredIDs = "DuplicateCredIDs",
    NonExistentCredIDs = "NonExistentCredIDs",
    RemoveFirstCredential = "RemoveFirstCredential",
    CredentialHolderDidNotSign = "CredentialHolderDidNotSign",
    NotAllowedMultipleCredentials = "NotAllowedMultipleCredentials",
    NotAllowedToReceiveEncrypted = "NotAllowedToReceiveEncrypted",
    NotAllowedToHandleEncrypted = "NotAllowedToHandleEncrypted",
    MissingBakerAddParameters = "MissingBakerAddParameters",
    FinalizationRewardCommissionNotInRange = "FinalizationRewardCommissionNotInRange",
    BakingRewardCommissionNotInRange = "BakingRewardCommissionNotInRange",
    TransactionFeeCommissionNotInRange = "TransactionFeeCommissionNotInRange",
    AlreadyADelegator = "AlreadyADelegator",
    InsufficientBalanceForDelegationStake = "InsufficientBalanceForDelegationStake",
    MissingDelegationAddParameters = "MissingDelegationAddParameters",
    InsufficientDelegationStake = "InsufficientDelegationStake",
    DelegatorInCooldown = "DelegatorInCooldown",
    NotADelegator = "NotADelegator",
    DelegationTargetNotABaker = "DelegationTargetNotABaker",
    StakeOverMaximumThresholdForPool = "StakeOverMaximumThresholdForPool",
    PoolWouldBecomeOverDelegated = "PoolWouldBecomeOverDelegated",
    PoolClosed = "PoolClosed"
}
export interface RejectedReceive {
    tag: RejectReasonTag.RejectedReceive;
    contractAddress: ContractAddress;
    receiveName: string;
    rejectReason: number;
    parameter: string;
}
export interface RejectedInit {
    tag: RejectReasonTag.RejectedInit;
    rejectReason: number;
}
export declare type SimpleRejectReasonTag = RejectReasonTag.ModuleNotWF | RejectReasonTag.RuntimeFailure | RejectReasonTag.SerializationFailure | RejectReasonTag.OutOfEnergy | RejectReasonTag.InvalidProof | RejectReasonTag.InsufficientBalanceForBakerStake | RejectReasonTag.StakeUnderMinimumThresholdForBaking | RejectReasonTag.BakerInCooldown | RejectReasonTag.NonExistentCredentialID | RejectReasonTag.KeyIndexAlreadyInUse | RejectReasonTag.InvalidAccountThreshold | RejectReasonTag.InvalidCredentialKeySignThreshold | RejectReasonTag.InvalidEncryptedAmountTransferProof | RejectReasonTag.InvalidTransferToPublicProof | RejectReasonTag.InvalidIndexOnEncryptedTransfer | RejectReasonTag.ZeroScheduledAmount | RejectReasonTag.NonIncreasingSchedule | RejectReasonTag.FirstScheduledReleaseExpired | RejectReasonTag.InvalidCredentials | RejectReasonTag.RemoveFirstCredential | RejectReasonTag.CredentialHolderDidNotSign | RejectReasonTag.NotAllowedMultipleCredentials | RejectReasonTag.NotAllowedToReceiveEncrypted | RejectReasonTag.NotAllowedToHandleEncrypted | RejectReasonTag.MissingBakerAddParameters | RejectReasonTag.FinalizationRewardCommissionNotInRange | RejectReasonTag.BakingRewardCommissionNotInRange | RejectReasonTag.TransactionFeeCommissionNotInRange | RejectReasonTag.AlreadyADelegator | RejectReasonTag.InsufficientBalanceForDelegationStake | RejectReasonTag.MissingDelegationAddParameters | RejectReasonTag.InsufficientDelegationStake | RejectReasonTag.DelegatorInCooldown | RejectReasonTag.StakeOverMaximumThresholdForPool | RejectReasonTag.PoolWouldBecomeOverDelegated | RejectReasonTag.PoolClosed;
export interface SimpleRejectReason {
    tag: SimpleRejectReasonTag;
}
export interface RejectReasonWithContents {
    tag: Exclude<RejectReasonTag, RejectReasonTag.RejectedReceive | RejectReasonTag.RejectedInit | SimpleRejectReasonTag>;
    contents: any;
}
export declare type RejectReason = RejectReasonWithContents | SimpleRejectReason | RejectedReceive | RejectedInit;
interface RejectedEventResult {
    outcome: 'reject';
    rejectReason: RejectReason;
}
interface SuccessfulEventResult {
    outcome: 'success';
    events: (TransactionEvent | TransferredEvent | UpdatedEvent | ResumedEvent | InterruptedEvent | MemoEvent | TransferredWithScheduleEvent)[];
}
export declare type EventResult = SuccessfulEventResult | TransferWithMemoEventResult | RejectedEventResult;
interface BaseTransactionSummaryType {
    type: 'accountTransaction' | 'credentialDeploymentTransaction' | 'updateTransaction';
}
export interface TransferWithMemoSummaryType extends BaseTransactionSummaryType {
    contents: 'transferWithMemo';
}
export interface GenericTransactionSummaryType extends BaseTransactionSummaryType {
    contents: string;
}
export interface BaseTransactionSummary {
    sender?: string;
    hash: string;
    cost: bigint;
    energyCost: bigint;
    index: bigint;
}
interface GenericTransactionSummary extends BaseTransactionSummary {
    type: GenericTransactionSummaryType;
    result: EventResult;
}
interface TransferWithMemoEventResult {
    outcome: 'success';
    events: [TransferredEvent, MemoEvent];
}
export interface TransferWithMemoTransactionSummary extends BaseTransactionSummary {
    type: TransferWithMemoSummaryType;
    result: TransferWithMemoEventResult;
}
export declare type TransactionSummary = GenericTransactionSummary | TransferWithMemoTransactionSummary;
export declare function instanceOfTransferWithMemoTransactionSummary(object: TransactionSummary): object is TransferWithMemoTransactionSummary;
export interface TransactionStatus {
    status: TransactionStatusEnum;
    outcomes?: Record<string, TransactionSummary>;
}
export interface PartyInfo {
    bakerId: bigint;
    weight: bigint;
    signed: boolean;
}
export interface FinalizationData {
    finalizationIndex: bigint;
    finalizationDelay: bigint;
    finalizationBlockPointer: string;
    finalizers: PartyInfo[];
}
export interface Ratio {
    numerator: bigint;
    denominator: bigint;
}
export declare type ExchangeRate = Ratio;
export interface InclusiveRange<N extends number> {
    min: N;
    max: N;
}
export declare type DurationSeconds = bigint;
/** Index of an epoch, or number of epochs. */
export declare type Epoch = bigint;
export interface TransactionFeeDistribution {
    baker: number;
    gasAccount: number;
}
export interface MintRate {
    mantissa: number;
    exponent: number;
}
interface MintDistributionCommon {
    bakingReward: number;
    finalizationReward: number;
}
export interface MintDistributionV0 extends MintDistributionCommon {
    mintPerSlot: number;
}
export declare type MintDistributionV1 = MintDistributionCommon;
export declare type MintDistribution = MintDistributionV0 | MintDistributionV1;
export interface GasRewards {
    baker: number;
    finalizationProof: number;
    accountCreation: number;
    chainUpdate: number;
}
interface RewardParametersCommon {
    transactionFeeDistribution: TransactionFeeDistribution;
    gASRewards: GasRewards;
}
/**
 * Used from protocol version 1-3
 */
export interface RewardParametersV0 extends RewardParametersCommon {
    mintDistribution: MintDistributionV0;
}
/**
 * Used from protocol version 4
 */
export interface RewardParametersV1 extends RewardParametersCommon {
    mintDistribution: MintDistributionV1;
}
export declare type RewardParameters = RewardParametersV0 | RewardParametersV1;
export interface CooldownParametersV0 {
    bakerCooldownEpochs: Epoch;
}
export interface CooldownParametersV1 {
    poolOwnerCooldown: DurationSeconds;
    delegatorCooldown: DurationSeconds;
}
export interface PoolParametersV0 {
    minimumThresholdForBaking: Amount;
}
export interface PoolParametersV1 {
    passiveFinalizationCommission: number;
    passiveBakingCommission: number;
    passiveTransactionCommission: number;
    finalizationCommissionRange: InclusiveRange<number>;
    bakingCommissionRange: InclusiveRange<number>;
    transactionCommissionRange: InclusiveRange<number>;
    minimumEquityCapital: Amount;
    capitalBound: number;
    leverageBound: Ratio;
}
export interface TimeParametersV1 {
    /**
     * In epochs
     */
    rewardPeriodLength: Epoch;
    mintPerPayday: number;
}
interface ChainParametersCommon {
    electionDifficulty: number;
    euroPerEnergy: ExchangeRate;
    microGTUPerEuro: ExchangeRate;
    accountCreationLimit: number;
    foundationAccountIndex: bigint;
}
/**
 * Used from protocol version 1-3
 */
export interface ChainParametersV0 extends ChainParametersCommon, CooldownParametersV0, PoolParametersV0 {
    rewardParameters: RewardParametersV0;
}
/**
 * Used from protocol version 4
 */
export interface ChainParametersV1 extends ChainParametersCommon, CooldownParametersV1, PoolParametersV1, TimeParametersV1 {
    rewardParameters: RewardParametersV1;
}
export declare type ChainParameters = ChainParametersV0 | ChainParametersV1;
export interface Authorization {
    threshold: number;
    authorizedKeys: number[];
}
interface AuthorizationsCommon {
    emergency: Authorization;
    microGTUPerEuro: Authorization;
    euroPerEnergy: Authorization;
    transactionFeeDistribution: Authorization;
    foundationAccount: Authorization;
    mintDistribution: Authorization;
    protocol: Authorization;
    paramGASRewards: Authorization;
    /**
     * For protocol version 3 and earlier, this controls the authorization of the bakerStakeThreshold update.
     */
    poolParameters: Authorization;
    electionDifficulty: Authorization;
    addAnonymityRevoker: Authorization;
    addIdentityProvider: Authorization;
    keys: VerifyKey[];
}
/**
 * Used from protocol version 1-3
 */
export declare type AuthorizationsV0 = AuthorizationsCommon;
/**
 * Used from protocol version 4
 */
export interface AuthorizationsV1 extends AuthorizationsCommon {
    cooldownParameters: Authorization;
    timeParameters: Authorization;
}
export declare type Authorizations = AuthorizationsV0 | AuthorizationsV1;
export interface KeysWithThreshold {
    keys: VerifyKey[];
    threshold: number;
}
interface KeysCommon {
    rootKeys: KeysWithThreshold;
    level1Keys: KeysWithThreshold;
}
/**
 * Used from protocol version 1-3
 */
export interface KeysV0 extends KeysCommon {
    level2Keys: AuthorizationsV0;
}
/**
 * Used from protocol version 4
 */
export interface KeysV1 extends KeysCommon {
    level2Keys: AuthorizationsV1;
}
export declare type Keys = KeysV0 | KeysV1;
export interface UpdateQueueQueue {
    effectiveTime: Date;
    /** Information about the actual update. */
    update: unknown;
}
export interface UpdateQueue {
    nextSequenceNumber: bigint;
    queue: UpdateQueueQueue;
}
interface UpdateQueuesCommon {
    microGTUPerEuro: UpdateQueue;
    euroPerEnergy: UpdateQueue;
    transactionFeeDistribution: UpdateQueue;
    foundationAccount: UpdateQueue;
    electionDifficulty: UpdateQueue;
    mintDistribution: UpdateQueue;
    protocol: UpdateQueue;
    gasRewards: UpdateQueue;
    addAnonymityRevoker: UpdateQueue;
    addIdentityProvider: UpdateQueue;
    rootKeys: UpdateQueue;
    level1Keys: UpdateQueue;
    level2Keys: UpdateQueue;
}
/**
 * Used from protocol version 1-3
 */
export interface UpdateQueuesV0 extends UpdateQueuesCommon {
    bakerStakeThreshold: UpdateQueue;
}
/**
 * Used from protocol version 4
 */
export interface UpdateQueuesV1 extends UpdateQueuesCommon {
    cooldownParameters: UpdateQueue;
    timeParameters: UpdateQueue;
    poolParameters: UpdateQueue;
}
export declare type UpdateQueues = UpdateQueuesV0 | UpdateQueuesV1;
interface ProtocolUpdate {
    message: string;
    specificationUrl: string;
    specificationHash: string;
    specificationAuxiliaryData: string;
}
interface UpdatesCommon {
    protocolUpdate: ProtocolUpdate | undefined;
}
/**
 * Used from protocol version 1-3
 */
export interface UpdatesV0 extends UpdatesCommon {
    chainParameters: ChainParametersV0;
    updateQueues: UpdateQueuesV0;
    keys: KeysV0;
}
/**
 * Used from protocol version 4
 */
export interface UpdatesV1 extends UpdatesCommon {
    chainParameters: ChainParametersV1;
    updateQueues: UpdateQueuesV1;
    keys: KeysV1;
}
export declare type Updates = UpdatesV0 | UpdatesV1;
interface BlockSummaryCommon {
    protocolVersion?: bigint;
    finalizationData: FinalizationData;
    transactionSummaries: TransactionSummary[];
}
/**
 * Used from protocol version 1-3
 */
export interface BlockSummaryV0 extends BlockSummaryCommon {
    updates: UpdatesV0;
}
/**
 * Used from protocol version 4
 */
export interface BlockSummaryV1 extends BlockSummaryCommon {
    updates: UpdatesV1;
    protocolVersion: bigint;
}
export declare type BlockSummary = BlockSummaryV0 | BlockSummaryV1;
interface RewardStatusCommon {
    protocolVersion?: bigint;
    totalAmount: Amount;
    totalEncryptedAmount: Amount;
    bakingRewardAccount: Amount;
    finalizationRewardAccount: Amount;
    gasAccount: Amount;
}
export declare type RewardStatusV0 = RewardStatusCommon;
export interface RewardStatusV1 extends RewardStatusCommon {
    foundationTransactionRewards: Amount;
    nextPaydayTime: Date;
    nextPaydayMintRate: MintRate;
    totalStakedCapital: Amount;
    protocolVersion: bigint;
}
export declare type RewardStatus = RewardStatusV0 | RewardStatusV1;
export interface BlockInfo {
    blockParent: string;
    blockHash: string;
    blockStateHash: string;
    blockLastFinalized: string;
    blockHeight: bigint;
    blockBaker: bigint;
    blockSlot: bigint;
    blockArriveTime: Date;
    blockReceiveTime: Date;
    blockSlotTime: Date;
    finalized: boolean;
    transactionCount: bigint;
    transactionsSize: bigint;
    transactionEnergyCost: bigint;
}
export interface ConsensusStatus {
    bestBlock: string;
    genesisBlock: string;
    currentEraGenesisBlock: string;
    lastFinalizedBlock: string;
    /**
     * In milliseconds
     */
    epochDuration: bigint;
    /**
     * In milliseconds
     */
    slotDuration: bigint;
    bestBlockHeight: bigint;
    lastFinalizedBlockHeight: bigint;
    finalizationCount: bigint;
    blocksVerifiedCount: bigint;
    blocksReceivedCount: bigint;
    blockArriveLatencyEMA: number;
    blockArriveLatencyEMSD: number;
    blockReceiveLatencyEMA: number;
    blockReceiveLatencyEMSD: number;
    transactionsPerBlockEMA: number;
    transactionsPerBlockEMSD: number;
    blockReceivePeriodEMA?: number;
    blockReceivePeriodEMSD?: number;
    blockArrivePeriodEMA?: number;
    blockArrivePeriodEMSD?: number;
    finalizationPeriodEMA?: number;
    finalizationPeriodEMSD?: number;
    genesisTime: Date;
    currentEraGenesisTime: Date;
    blockLastReceivedTime?: Date;
    blockLastArrivedTime?: Date;
    lastFinalizedTime?: Date;
    genesisIndex: number;
    protocolVersion: bigint;
}
export interface CryptographicParameters {
    onChainCommitmentKey: string;
    bulletproofGenerators: string;
    genesisString: string;
}
export interface NextAccountNonce {
    nonce: bigint;
    allFinal: boolean;
}
export interface ReleaseSchedule {
    timestamp: Date;
    amount: bigint;
}
export interface ReleaseScheduleWithTransactions extends ReleaseSchedule {
    transactions: string[];
}
export interface AccountReleaseSchedule {
    total: bigint;
    schedule: ReleaseScheduleWithTransactions[];
}
export interface AccountEncryptedAmount {
    selfAmount: string;
    startIndex: bigint;
    incomingAmounts: string[];
    numAggregated?: number;
    aggregatedAmount?: string;
}
export interface VerifyKey {
    schemeId: string;
    verifyKey: string;
}
export interface CredentialPublicKeys {
    keys: Record<number, VerifyKey>;
    threshold: number;
}
export interface ChainArData {
    encIdCredPubShare: string;
}
export interface Policy {
    validTo: string;
    createdAt: string;
    revealedAttributes: Record<AttributeKey, string>;
}
interface SharedCredentialDeploymentValues {
    ipIdentity: number;
    credentialPublicKeys: CredentialPublicKeys;
    policy: Policy;
}
export interface CredentialDeploymentValues extends SharedCredentialDeploymentValues {
    credId: string;
    revocationThreshold: number;
    arData: Record<string, ChainArData>;
    commitments: CredentialDeploymentCommitments;
}
export interface InitialCredentialDeploymentValues extends SharedCredentialDeploymentValues {
    regId: string;
}
export interface CredentialDeploymentCommitments {
    cmmPrf: string;
    cmmCredCounter: string;
    cmmIdCredSecSharingCoeff: string[];
    cmmAttributes: Record<AttributeKey, string>;
    cmmMaxAccounts: string;
}
export interface NormalAccountCredential {
    type: 'normal';
    contents: CredentialDeploymentValues;
}
export interface InitialAccountCredential {
    type: 'initial';
    contents: InitialCredentialDeploymentValues;
}
export declare enum StakePendingChangeType {
    ReduceStake = "ReduceStake",
    RemoveStakeV0 = "RemoveBaker",
    RemoveStakeV1 = "RemoveStake"
}
interface StakePendingChangeV0Common {
    epoch: bigint;
}
interface StakePendingChangeV1Common {
    effectiveTime: Date;
}
interface ReduceStakePendingChangeCommon {
    newStake: bigint;
}
export interface ReduceStakePendingChangeV0 extends ReduceStakePendingChangeCommon, StakePendingChangeV0Common {
    change: StakePendingChangeType.ReduceStake;
}
export interface ReduceStakePendingChangeV1 extends ReduceStakePendingChangeCommon, StakePendingChangeV1Common {
    change: StakePendingChangeType.ReduceStake;
}
export declare type ReduceStakePendingChange = ReduceStakePendingChangeV0 | ReduceStakePendingChangeV1;
export interface RemovalPendingChangeV0 extends StakePendingChangeV0Common {
    change: StakePendingChangeType.RemoveStakeV0;
}
export interface RemovalPendingChangeV1 extends StakePendingChangeV1Common {
    change: StakePendingChangeType.RemoveStakeV1;
}
export declare type RemovalPendingChange = RemovalPendingChangeV0 | RemovalPendingChangeV1;
export declare type StakePendingChangeV0 = ReduceStakePendingChangeV0 | RemovalPendingChangeV0;
export declare type StakePendingChangeV1 = ReduceStakePendingChangeV1 | RemovalPendingChangeV1;
export declare type StakePendingChange = StakePendingChangeV0 | StakePendingChangeV1;
export declare enum OpenStatus {
    OpenForAll = 0,
    ClosedForNew = 1,
    ClosedForAll = 2
}
/**
 * How the node translates OpenStatus to JSON.
 */
export declare enum OpenStatusText {
    OpenForAll = "openForAll",
    ClosedForNew = "closedForNew",
    ClosedForAll = "closedForAll"
}
export declare type Amount = bigint;
export declare type BakerId = bigint;
export interface BakerPoolInfo {
    openStatus: OpenStatusText;
    metadataUrl: string;
    commissionRates: CommissionRates;
}
export interface CommissionRates {
    transactionCommission: number;
    bakingCommission: number;
    finalizationCommission: number;
}
export interface CurrentPaydayBakerPoolStatus {
    blocksBaked: bigint;
    finalizationLive: boolean;
    transactionFeesEarned: Amount;
    effectiveStake: Amount;
    lotteryPower: number;
    bakerEquityCapital: Amount;
    delegatedCapital: Amount;
}
export declare enum BakerPoolPendingChangeType {
    ReduceBakerCapital = "ReduceBakerCapital",
    RemovePool = "RemovePool",
    NoChange = "NoChange"
}
declare type BakerPoolPendingChangeWrapper<T extends keyof typeof BakerPoolPendingChangeType, S extends Record<string, any>> = S & {
    pendingChangeType: T;
};
export interface BakerPoolPendingChangeReduceBakerCapitalDetails {
    bakerEquityCapital: Amount;
    effectiveTime: Date;
}
export declare type BakerPoolPendingChangeReduceBakerCapital = BakerPoolPendingChangeWrapper<BakerPoolPendingChangeType.ReduceBakerCapital, BakerPoolPendingChangeReduceBakerCapitalDetails>;
export interface BakerPoolPendingChangeRemovePoolDetails {
    effectiveTime: Date;
}
export declare type BakerPoolPendingChangeRemovePool = BakerPoolPendingChangeWrapper<BakerPoolPendingChangeType.RemovePool, BakerPoolPendingChangeRemovePoolDetails>;
export declare type BakerPoolPendingChangeNoChange = BakerPoolPendingChangeWrapper<BakerPoolPendingChangeType.NoChange, {}>;
export declare type BakerPoolPendingChange = BakerPoolPendingChangeReduceBakerCapital | BakerPoolPendingChangeRemovePool | BakerPoolPendingChangeNoChange;
export declare enum PoolStatusType {
    BakerPool = "BakerPool",
    PassiveDelegation = "PassiveDelegation"
}
declare type PoolStatusWrapper<T extends keyof typeof PoolStatusType, S> = S & {
    poolType: T;
};
export interface BakerPoolStatusDetails {
    bakerId: BakerId;
    bakerAddress: string;
    bakerEquityCapital: Amount;
    delegatedCapital: Amount;
    delegatedCapitalCap: Amount;
    poolInfo: BakerPoolInfo;
    bakerStakePendingChange: BakerPoolPendingChange;
    currentPaydayStatus?: CurrentPaydayBakerPoolStatus;
}
export declare type BakerPoolStatus = PoolStatusWrapper<PoolStatusType.BakerPool, BakerPoolStatusDetails>;
export interface PassiveDelegationStatusDetails {
    delegatedCapital: Amount;
    commissionRates: CommissionRates;
    currentPaydayTransactionFeesEarned: Amount;
    currentPaydayDelegatedCapital: Amount;
}
export declare type PassiveDelegationStatus = PoolStatusWrapper<PoolStatusType.PassiveDelegation, PassiveDelegationStatusDetails>;
export declare type PoolStatus = BakerPoolStatus | PassiveDelegationStatus;
export declare enum DelegationTargetType {
    PassiveDelegation = "Passive",
    Baker = "Baker"
}
export interface DelegationTargetPassiveDelegation {
    delegateType: DelegationTargetType.PassiveDelegation;
}
export interface DelegationTargetBaker {
    delegateType: DelegationTargetType.Baker;
    bakerId: BakerId;
}
export declare type DelegationTarget = DelegationTargetPassiveDelegation | DelegationTargetBaker;
interface AccountBakerDetailsCommon {
    restakeEarnings: boolean;
    bakerId: BakerId;
    bakerAggregationVerifyKey: string;
    bakerElectionVerifyKey: string;
    bakerSignatureVerifyKey: string;
    stakedAmount: bigint;
    pendingChange?: StakePendingChange;
}
export declare type AccountBakerDetailsV0 = AccountBakerDetailsCommon;
export interface AccountBakerDetailsV1 extends AccountBakerDetailsCommon {
    bakerPoolInfo: BakerPoolInfo;
}
export declare type AccountBakerDetails = AccountBakerDetailsV0 | AccountBakerDetailsV1;
export interface AccountDelegationDetails {
    restakeEarnings: boolean;
    stakedAmount: bigint;
    delegationTarget: DelegationTarget;
    pendingChange?: StakePendingChangeV1;
}
export declare type AccountCredential = Versioned<InitialAccountCredential | NormalAccountCredential>;
interface AccountInfoCommon {
    accountAddress: string;
    accountNonce: bigint;
    accountAmount: bigint;
    accountIndex: bigint;
    accountThreshold: number;
    accountEncryptionKey: string;
    accountEncryptedAmount: AccountEncryptedAmount;
    accountReleaseSchedule: AccountReleaseSchedule;
    accountCredentials: Record<number, AccountCredential>;
}
export declare type AccountInfoSimple = AccountInfoCommon;
export interface AccountInfoBakerV0 extends AccountInfoCommon {
    accountBaker: AccountBakerDetailsV0;
}
/** Protocol version 4 and later. */
export interface AccountInfoBakerV1 extends AccountInfoCommon {
    accountBaker: AccountBakerDetailsV1;
}
export declare type AccountInfoBaker = AccountInfoBakerV0 | AccountInfoBakerV1;
/** Protocol version 4 and later. */
export interface AccountInfoDelegator extends AccountInfoCommon {
    accountDelegation: AccountDelegationDetails;
}
export declare type AccountInfo = AccountInfoSimple | AccountInfoBaker | AccountInfoDelegator;
export interface Description {
    name: string;
    url: string;
    description: string;
}
export interface IpInfo {
    ipIdentity: number;
    ipDescription: Description;
    ipVerifyKey: string;
    ipCdiVerifyKey: string;
}
export interface ArInfo {
    arIdentity: number;
    arDescription: Description;
    arPublicKey: string;
}
export declare enum BlockItemKind {
    AccountTransactionKind = 0,
    CredentialDeploymentKind = 1,
    UpdateInstructionKind = 2
}
/**
 * The different types of account transactions. The number value
 * is important as it is part of the serialization of a particular
 * transaction.
 */
export declare enum AccountTransactionType {
    DeployModule = 0,
    InitContract = 1,
    Update = 2,
    Transfer = 3,
    AddBaker = 4,
    RemoveBaker = 5,
    UpdateBakerStake = 6,
    UpdateBakerRestakeEarnings = 7,
    UpdateBakerKeys = 8,
    UpdateCredentialKeys = 13,
    EncryptedAmountTransfer = 16,
    TransferToEncrypted = 17,
    TransferToPublic = 18,
    TransferWithSchedule = 19,
    UpdateCredentials = 20,
    RegisterData = 21,
    TransferWithMemo = 22,
    EncryptedAmountTransferWithMemo = 23,
    TransferWithScheduleWithMemo = 24,
    ConfigureBaker = 25,
    ConfigureDelegation = 26
}
export declare function isAccountTransactionType(candidate: number): candidate is AccountTransactionType;
export interface DeployModulePayload {
    /** Version of the wasm module. This should only be supplied if wasm module is not already versioned. */
    version?: number;
    /** Wasm module to be deployed */
    source: Buffer;
}
export interface InitContractPayload {
    /** µCCD amount to transfer */
    amount: CcdAmount;
    /** Hash of the module on chain */
    moduleRef: ModuleReference;
    /** Name of the contract */
    initName: string;
    /** Parameters for the init function */
    param: Buffer;
    /** The amount of energy that can be used for contract execution.
    The base energy amount for transaction verification will be added to this cost.*/
    maxContractExecutionEnergy: bigint;
}
export interface UpdateContractPayload {
    /** µCCD amount to transfer */
    amount: CcdAmount;
    /** Address of contract instance consisting of an index and a subindex */
    address: ContractAddress;
    /** Name of receive function including <contractName>. prefix */
    receiveName: string;
    /** Parameters for the update function */
    message: Buffer;
    /** The amount of energy that can be used for contract execution.
    The base energy amount for transaction verification will be added to this cost.*/
    maxContractExecutionEnergy: bigint;
}
export interface AccountTransactionHeader {
    /** account address that is source of this transaction */
    sender: AccountAddress;
    /**
     * the nonce for the transaction, usually acquired by
     * getting the next account nonce from the node
     */
    nonce: bigint;
    /** expiration of the transaction */
    expiry: TransactionExpiry;
}
export interface SimpleTransferPayload {
    /** µCCD amount to transfer */
    amount: CcdAmount;
    /** the recipient of the transfer */
    toAddress: AccountAddress;
}
export interface SimpleTransferWithMemoPayload extends SimpleTransferPayload {
    /** The byte representation of the memo of the transaction  */
    memo: DataBlob;
}
export interface RegisterDataPayload {
    /** The byte representation of the data to be registered  */
    data: DataBlob;
}
export interface IndexedCredentialDeploymentInfo {
    /** the index of the credential, has to fit in 1 byte */
    index: number;
    /** the credential signed by the credential owner */
    cdi: CredentialDeploymentInfo;
}
export interface UpdateCredentialsPayload {
    /** the credentials to be added to the account */
    newCredentials: IndexedCredentialDeploymentInfo[];
    /** the ids of the credentials to be removed */
    removeCredentialIds: string[];
    /** the new credential threshold required to sign transactions */
    threshold: number;
    /**
     * the current number of credentials on the account. This
     * is required to be able to calculate the energy cost, but
     * is not part of the actual transaction.
     */
    currentNumberOfCredentials: bigint;
}
export interface ConfigureDelegationPayload {
    stake?: CcdAmount;
    restakeEarnings?: boolean;
    delegationTarget?: DelegationTarget;
}
export declare type AccountTransactionPayload = SimpleTransferPayload | SimpleTransferWithMemoPayload | RegisterDataPayload | DeployModulePayload | InitContractPayload | UpdateContractPayload | UpdateCredentialsPayload | ConfigureDelegationPayload;
export interface AccountTransaction {
    type: AccountTransactionType;
    header: AccountTransactionHeader;
    payload: AccountTransactionPayload;
}
export declare enum ParameterType {
    /** Nothing. */
    Unit = 0,
    /** Boolean (`true` or `false`). */
    Bool = 1,
    /** Unsigned 8-bit integer. */
    U8 = 2,
    /** Unsigned 16-bit integer. */
    U16 = 3,
    /** Unsigned 32-bit integer. */
    U32 = 4,
    /** Unsigned 64-bit integer. */
    U64 = 5,
    /** Signed 8-bit integer. */
    I8 = 6,
    /** Signed 16-bit integer. */
    I16 = 7,
    /** Signed 32-bit integer. */
    I32 = 8,
    /** Signed 64-bit integer. */
    I64 = 9,
    /** Token amount in microCCD (10^-6 GTU). */
    Amount = 10,
    /** Sender account address. */
    AccountAddress = 11,
    /** Address of the contract instance consisting of an index and a subindex. */
    ContractAddress = 12,
    /** Unsigned 64-bit integer storing milliseconds since UNIX epoch and representing a timestamp. */
    Timestamp = 13,
    /** Unsigned 64-bit integer storing milliseconds and representing a duration. */
    Duration = 14,
    /** Tuple. */
    Pair = 15,
    /** Variable size list. */
    List = 16,
    /** Unordered collection of unique elements. */
    Set = 17,
    /** Unordered map from keys to values.  */
    Map = 18,
    /** Fixed size array. */
    Array = 19,
    /** Struct. */
    Struct = 20,
    /** Enum. */
    Enum = 21,
    /** List of bytes representing a string. */
    String = 22,
    /** Unsigned 128-bit integer. */
    U128 = 23,
    /** Signed 128-bit integer. */
    I128 = 24,
    /** Name of the contract. */
    ContractName = 25,
    /** Receive function name. */
    ReceiveName = 26,
    /** LEB128 encoding of an unsigned integer */
    ULeb128 = 27,
    /** LEB128 encoding of a signed integer */
    ILeb128 = 28,
    /** Variable size list of bytes */
    ByteList = 29,
    /** Fixed size list of bytes */
    ByteArray = 30
}
export interface InstanceInfoCommon {
    version: number;
    amount: CcdAmount;
    sourceModule: ModuleReference;
    owner: AccountAddress;
    methods: string[];
    name: string;
}
export interface InstanceInfoV0 extends InstanceInfoCommon {
    version: 0;
    model: Buffer;
}
export interface InstanceInfoV1 extends InstanceInfoCommon {
    version: 1;
}
export declare type InstanceInfo = InstanceInfoV0 | InstanceInfoV1;
export declare const isInstanceInfoV1: (info: InstanceInfo) => info is InstanceInfoV1;
export declare const isInstanceInfoV0: (info: InstanceInfo) => info is InstanceInfoV0;
export declare type CredentialSignature = Record<number, string>;
export declare type AccountTransactionSignature = Record<number, CredentialSignature>;
export interface InstanceInfoSerializedCommon {
    version?: number;
    amount: string;
    sourceModule: string;
    owner: string;
    methods: string[];
    name: string;
}
export interface InstanceInfoSerializedV0 extends InstanceInfoSerializedCommon {
    version?: 0;
    model: string;
}
export interface InstanceInfoSerializedV1 extends InstanceInfoSerializedCommon {
    version: 1;
}
export declare type InstanceInfoSerialized = InstanceInfoSerializedV0 | InstanceInfoSerializedV1;
export interface ContractContext {
    invoker?: ContractAddress | AccountAddress;
    contract: ContractAddress;
    amount?: CcdAmount;
    method: string;
    parameter?: Buffer;
    energy?: bigint;
}
/**
 * Format of invoker expected by the node for the invokeContract entrypoint.
 */
export declare type Invoker = {
    type: 'AddressContract';
    address: {
        index: string;
        subindex: string;
    };
} | {
    type: 'AddressAccount';
    address: string;
} | null;
/**
 * Takes an accountAddress or ContractAddress and transforms it into the specific format used for
 * InvokeContract's invoker parameter.
 */
export declare function buildInvoker(invoker?: AccountAddress | ContractAddress): Invoker;
export interface InvokeContractSuccessResult extends Pick<SuccessfulEventResult, 'events'> {
    tag: 'success';
    usedEnergy: bigint;
    returnValue?: string;
}
export interface InvokeContractFailedResult {
    tag: 'failure';
    usedEnergy: bigint;
    reason: RejectReason;
}
export declare type InvokeContractResult = InvokeContractSuccessResult | InvokeContractFailedResult;
export interface CredentialDeploymentDetails {
    expiry: TransactionExpiry;
    unsignedCdi: UnsignedCredentialDeploymentInformation;
}
export interface IdOwnershipProofs {
    challenge: string;
    commitments: string;
    credCounterLessThanMaxAccounts: string;
    proofIdCredPub: Record<string, string>;
    proofIpSig: string;
    proofRegId: string;
    sig: string;
}
export interface UnsignedCredentialDeploymentInformation extends CredentialDeploymentValues {
    proofs: IdOwnershipProofs;
}
declare type AttributesRandomness = Record<AttributeKey, string>;
export interface CommitmentsRandomness {
    idCredSecRand: string;
    prfRand: string;
    credCounterRand: string;
    maxAccountsRand: string;
    attributesRand: AttributesRandomness;
}
interface CdiRandomness {
    randomness: CommitmentsRandomness;
}
export declare type CredentialDeploymentTransaction = CredentialDeploymentDetails & CdiRandomness;
/** Internal type used when building credentials */
export declare type UnsignedCdiWithRandomness = {
    unsignedCdi: UnsignedCredentialDeploymentInformation;
} & CdiRandomness;
export interface CredentialDeploymentInfo extends CredentialDeploymentValues {
    proofs: string;
}
export interface SignedCredentialDeploymentDetails {
    expiry: TransactionExpiry;
    cdi: CredentialDeploymentInfo;
}
export declare type TypedCredentialDeployment = {
    type: 'normal';
    contents: CredentialDeploymentInfo;
} | {
    type: 'initial';
    contents: InitialCredentialDeploymentValues & {
        sig: string;
    };
};
export interface IdentityProvider {
    arsInfos: Record<number, ArInfo>;
    ipInfo: IpInfo;
}
export interface IdentityInput {
    identityProvider: IdentityProvider;
    identityObject: any;
    prfKey: string;
    idCredSecret: string;
    randomness: string;
}
export declare enum SchemaVersion {
    V0 = 0,
    V1 = 1,
    V2 = 2
}
export declare type IpArData = {
    encPrfKeyShare: string;
    proofComEncEq: string;
};
export interface IdObjectRequestV1 {
    idCredPub: string;
    choiceArData: {
        arIdentities: number[];
        threshold: number;
    };
    ipArData: Record<string, IpArData>;
    idCredSecCommitment: string;
    prfKeyCommitmentWithIP: string;
    prfKeySharingCoeffCommitments: string[];
    proofsOfKnowledge: string;
}
export interface IdRecoveryRequest {
    idCredPub: string;
    timestamp: bigint;
    proof: string;
}
export interface AttributeList {
    validTo: string;
    createdAt: string;
    maxAccounts: number;
    chosenAttributes: Record<AttributeKey, string>;
}
export declare type IdentityObjectV1 = {
    preIdentityObject: IdObjectRequestV1;
    attributeList: AttributeList;
    signature: string;
};
export declare type Network = 'Testnet' | 'Mainnet';
export {};
