/**
 * WebGL numeric type constants. Use {@link GL2TYPE} to convert, if needed.
 *
 * {@link Type}
 * {@link GL2TYPE}
 * {@link TYPE2GL}
 */
export var GLType;
(function (GLType) {
    GLType[GLType["I8"] = 5120] = "I8";
    GLType[GLType["U8"] = 5121] = "U8";
    GLType[GLType["I16"] = 5122] = "I16";
    GLType[GLType["U16"] = 5123] = "U16";
    GLType[GLType["I32"] = 5124] = "I32";
    GLType[GLType["U32"] = 5125] = "U32";
    GLType[GLType["F32"] = 5126] = "F32";
})(GLType || (GLType = {}));
/**
 * Conversion from {@link GLType} to {@link Type} enums.
 */
export const GL2TYPE = {
    [GLType.I8]: "i8",
    [GLType.U8]: "u8",
    [GLType.I16]: "i16",
    [GLType.U16]: "u16",
    [GLType.I32]: "i32",
    [GLType.U32]: "u32",
    [GLType.F32]: "f32",
};
/**
 * Potentially lossy conversion from {@link Type} to {@link GLType} enums.
 *
 * Not all enums are mappable:
 *
 * - `F64` maps to `undefined`, since unsupported by WebGL
 * - `U8C` maps to "u8"
 */
export const TYPE2GL = {
    i8: GLType.I8,
    u8: GLType.U8,
    u8c: GLType.U8,
    i16: GLType.I16,
    u16: GLType.U16,
    i32: GLType.I32,
    u32: GLType.U32,
    f32: GLType.F32,
    f64: undefined,
};
/**
 * Size information (in bytes) for {@link Type} and {@link BigType}. Also see
 * {@link sizeOf}.
 */
export const SIZEOF = {
    u8: 1,
    u8c: 1,
    i8: 1,
    u16: 2,
    i16: 2,
    u32: 4,
    i32: 4,
    i64: 8,
    u64: 8,
    f32: 4,
    f64: 8,
};
/**
 * Bit shift values to convert byte addresses into array indices for all
 * {@link Type}s and {@link BigType}s.
 */
export const BIT_SHIFTS = {
    i8: 0,
    u8: 0,
    u8c: 0,
    i16: 1,
    u16: 1,
    i32: 2,
    u32: 2,
    i64: 3,
    u64: 3,
    f32: 2,
    f64: 3,
};
export const FLOAT_ARRAY_CTORS = {
    f32: Float32Array,
    f64: Float64Array,
};
export const INT_ARRAY_CTORS = {
    i8: Int8Array,
    i16: Int16Array,
    i32: Int32Array,
};
export const UINT_ARRAY_CTORS = {
    u8: Uint8Array,
    u8c: Uint8ClampedArray,
    u16: Uint16Array,
    u32: Uint32Array,
};
export const BIGINT_ARRAY_CTORS = {
    i64: BigInt64Array,
    u64: BigUint64Array,
};
export const TYPEDARRAY_CTORS = {
    ...FLOAT_ARRAY_CTORS,
    ...INT_ARRAY_CTORS,
    ...UINT_ARRAY_CTORS,
};
/**
 * Returns canonical {@link Type} value of `type` by first
 * attempting to resolve it as {@link GLType} enum.
 *
 * @example
 * ```ts
 * asNativeType(GLType.F32) => "f32"
 * asNativeType("f32") => "f32"
 * ```
 *
 * @param type -
 */
export const asNativeType = (type) => {
    const t = GL2TYPE[type];
    return t !== undefined ? t : type;
};
/**
 * Returns suitable {@link GLType} enum of `type`.
 *
 * @example
 * ```ts
 * asGLType("f32") => GLType.F32
 * asGLType(GLType.F32) => GLType.F32
 * ```
 *
 * @param type -
 */
export const asGLType = (type) => {
    const t = TYPE2GL[type];
    return t !== undefined ? t : type;
};
/**
 * Coerces given numeric args to integer values.
 */
export const asInt = (...args) => args.map((x) => x | 0);
/**
 * Returns byte size for given {@link Type} ID or {@link GLType} enum.
 *
 * @param type -
 */
export const sizeOf = (type) => SIZEOF[type] || SIZEOF[asNativeType(type)];
export function typedArray(type, ...xs) {
    const ctor = BIGINT_ARRAY_CTORS[type];
    return new (ctor || TYPEDARRAY_CTORS[asNativeType(type)])(...xs);
}
/**
 * Takes an {@link NumericArray} and returns its corresponding {@link Type} ID.
 * Standard JS arrays will default to {@link "f64"}.
 *
 * @param x -
 */
export const typedArrayType = (x) => {
    if (Array.isArray(x))
        return "f64";
    for (let id in TYPEDARRAY_CTORS) {
        if (x instanceof TYPEDARRAY_CTORS[id])
            return id;
    }
    return "f64";
};
/**
 * Returns the smallest possible *unsigned* int type enum for given `x`.
 * E.g. if `x <= 256`, the function returns `"u8"`.
 *
 * @param x - value to classify
 */
export const uintTypeForSize = (x) => x <= 0x100 ? "u8" : x <= 0x10000 ? "u16" : "u32";
/**
 * Returns the smallest possible *signed* int type enum for given `x`.
 * E.g. if `x >= -128 && x < 128`, the function returns `"i8"`.
 *
 * @param x - value to classify
 */
export const intTypeForSize = (x) => x >= -0x80 && x < 0x80 ? "i8" : x >= -0x8000 && x < 0x8000 ? "i16" : "i32";
/**
 * Returns suitable {@link UintType} for given bit size (`[0,32]` range)
 *
 * @param x -
 */
export const uintTypeForBits = (x) => x > 16 ? "u32" : x > 8 ? "u16" : "u8";
/**
 * Returns suitable {@link IntType} for given bit size (`[0,32]` range)
 *
 * @param x -
 */
export const intTypeForBits = (x) => x > 16 ? "i32" : x > 8 ? "i16" : "i8";
/**
 * Returns the next smaller {@link IntType} for given type (or the same type if
 * already the narrowest).
 *
 * @param t
 */
export const narrowInt = (t) => t === "i64" ? "i32" : t === "i32" ? "i16" : t === "i16" ? "i8" : "i8";
/**
 * Returns the next larger {@link IntType} for given type (or the same type if
 * already the widest).
 *
 * @param t
 */
export const widenInt = (t) => t === "i8" ? "i16" : t === "i16" ? "i32" : t === "i32" ? "i64" : "i64";
/**
 * Returns the next smaller {@link UintType} for given type (or the same type if
 * already the narrowest).
 *
 * @remarks
 * If type is `u8c`, returns `u8`.
 *
 * @param t
 */
export const narrowUint = (t) => t === "u64" ? "u32" : t === "u32" ? "u16" : t === "u16" ? "u8" : "u8";
/**
 * Returns the next larger {@link UintType} for given type (or the same type if
 * already the widest).
 *
 * @param t
 */
export const widenUint = (t) => t === "u8" || t === "u8c"
    ? "u16"
    : t === "u16"
        ? "u32"
        : t === "u32"
            ? "u64"
            : "u64";
/**
 * Returns the next smaller {@link FloatType} for given type (or the same type
 * if already the narrowest).
 *
 * @param t
 */
export const narrowFloat = (t) => (t === "f64" ? "f32" : "f32");
/**
 * Returns the next larger {@link FloatType} for given type (or the same type if
 * already the widest).
 *
 * @param t
 */
export const widenFloat = (t) => (t === "f32" ? "f64" : "f64");
/**
 * Returns the next smaller type (i.e. {@link IntType}, {@link UintType} or
 * {@link FloatType}) for given type (or the same type if already the smallest).
 *
 * @param t
 */
export const narrowType = (t) => t[0] === "i"
    ? narrowInt(t)
    : t[0] === "u"
        ? narrowUint(t)
        : narrowFloat(t);
/**
 * Returns the next larger type (i.e. {@link IntType}, {@link UintType} or
 * {@link FloatType}) for given type (or the same type if already the widest).
 *
 * @param t
 */
export const widenType = (t) => t[0] === "i"
    ? widenInt(t)
    : t[0] === "u"
        ? widenUint(t)
        : widenFloat(t);
