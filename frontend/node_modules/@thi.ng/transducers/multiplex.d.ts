import type { Transducer, TxLike } from "./api.js";
/**
 * Yields a new transducer which applies given transducers in parallel (using
 * [`juxt()`](https://docs.thi.ng/umbrella/compose/functions/juxt.html) &
 * {@link step}) and produces tuples of results.
 *
 * @remarks
 * Use the {@link noop} transducer for processing lanes which should retain the
 * original input values.
 *
 * @example
 * ```ts
 * [...iterator(
 *   multiplex(
 *     map(x => x.charAt(0)),
 *     map(x => x.toUpperCase()),
 *     map(x => x.length)
 *   ),
 *   ["Alice", "Bob", "Charlie", "Andy"]
 * )]
 * // [ [ "A", "ALICE", 5 ], [ "B", "BOB", 3 ], [ "C", "CHARLIE", 7 ] ]
 * ```
 *
 * @param a -
 */
export declare function multiplex<T, A>(a: TxLike<T, A>): Transducer<T, [A]>;
export declare function multiplex<T, A, B>(a: TxLike<T, A>, b: TxLike<T, B>): Transducer<T, [A, B]>;
export declare function multiplex<T, A, B, C>(a: TxLike<T, A>, b: TxLike<T, B>, c: TxLike<T, C>): Transducer<T, [A, B, C]>;
export declare function multiplex<T, A, B, C, D>(a: TxLike<T, A>, b: TxLike<T, B>, c: TxLike<T, C>, d: TxLike<T, D>): Transducer<T, [A, B, C, D]>;
export declare function multiplex<T, A, B, C, D, E>(a: TxLike<T, A>, b: TxLike<T, B>, c: TxLike<T, C>, d: TxLike<T, D>, e: TxLike<T, E>): Transducer<T, [A, B, C, D, E]>;
export declare function multiplex<T, A, B, C, D, E, F>(a: TxLike<T, A>, b: TxLike<T, B>, c: TxLike<T, C>, d: TxLike<T, D>, e: TxLike<T, E>, f: TxLike<T, F>): Transducer<T, [A, B, C, D, E, F]>;
export declare function multiplex<T, A, B, C, D, E, F, G>(a: TxLike<T, A>, b: TxLike<T, B>, c: TxLike<T, C>, d: TxLike<T, D>, e: TxLike<T, E>, f: TxLike<T, F>, g: TxLike<T, G>): Transducer<T, [A, B, C, D, E, F, G]>;
export declare function multiplex<T, A, B, C, D, E, F, G, H>(a: TxLike<T, A>, b: TxLike<T, B>, c: TxLike<T, C>, d: TxLike<T, D>, e: TxLike<T, E>, f: TxLike<T, F>, g: TxLike<T, G>, h: TxLike<T, H>): Transducer<T, [A, B, C, D, E, F, G, H]>;
//# sourceMappingURL=multiplex.d.ts.map